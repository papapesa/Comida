<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<title>Mini Minecraft Avançado</title>
<style>
  body { margin:0; overflow:hidden; background:#87ceeb; font-family: Arial, sans-serif; }
  #info {
    position: absolute; top:10px; left:10px; color: #fff;
    background: rgba(0,0,0,0.5); padding:10px; max-width:320px;
    user-select:none; z-index:10;
  }
  #blockSelector {
    position: absolute; bottom:10px; left:50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.5); padding:5px 10px; border-radius:5px;
    user-select:none; z-index:10;
  }
  .blockSlot {
    display: inline-block; width:40px; height:40px; margin:0 5px;
    border: 2px solid white; text-align:center; line-height:40px; font-weight:bold;
    cursor:pointer; user-select:none;
  }
  .selected { border-color: yellow !important; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="info">
  <b>Controles:</b><br>
  WASD = mover | Espaço = pular | Mouse = olhar<br>
  Clique esquerdo = colocar bloco | Clique direito = remover bloco<br>
  Teclas 1,2,3 para trocar bloco selecionado
</div>
<div id="blockSelector">
  <div class="blockSlot selected" data-type="terra" style="background:#8B4513;" title="Terra">1</div>
  <div class="blockSlot" data-type="pedra" style="background:#808080;" title="Pedra">2</div>
  <div class="blockSlot" data-type="madeira" style="background:#DEB887;" title="Madeira">3</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  // Setup básico
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Luz ambiente + direcional
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(10, 20, 10);
  dirLight.castShadow = true;
  scene.add(dirLight);

  // Controle FPS com PointerLock
  const controls = new THREE.PointerLockControls(camera, document.body);
  document.body.addEventListener('click', () => controls.lock());

  // Variáveis de movimento
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();
  const move = { forward:false, backward:false, left:false, right:false };
  let canJump = false;
  const gravity = 30;
  const playerHeight = 1.8;

  // Inventário / bloco selecionado
  let selectedBlock = 'terra';

  const blockSelector = document.getElementById('blockSelector');
  const slots = blockSelector.querySelectorAll('.blockSlot');
  slots.forEach(slot => {
    slot.addEventListener('click', () => {
      slots.forEach(s => s.classList.remove('selected'));
      slot.classList.add('selected');
      selectedBlock = slot.dataset.type;
    });
  });

  // Controle teclado
  window.addEventListener('keydown', (e) => {
    switch(e.code){
      case 'KeyW': move.forward = true; break;
      case 'KeyS': move.backward = true; break;
      case 'KeyA': move.left = true; break;
      case 'KeyD': move.right = true; break;
      case 'Space':
        if(canJump) velocity.y = 10;
        canJump = false;
        break;
      case 'Digit1':
      case 'Digit2':
      case 'Digit3':
        const idx = parseInt(e.code.charAt(5))-1;
        if(slots[idx]){
          slots.forEach(s => s.classList.remove('selected'));
          slots[idx].classList.add('selected');
          selectedBlock = slots[idx].dataset.type;
        }
        break;
    }
  });
  window.addEventListener('keyup', (e) => {
    switch(e.code){
      case 'KeyW': move.forward = false; break;
      case 'KeyS': move.backward = false; break;
      case 'KeyA': move.left = false; break;
      case 'KeyD': move.right = false; break;
    }
  });

  // Materiais blocos (cores sólidas)
  const materials = {
    terra: new THREE.MeshLambertMaterial({color: 0x8B4513}),
    pedra: new THREE.MeshLambertMaterial({color: 0x808080}),
    madeira: new THREE.MeshLambertMaterial({color: 0xDEB887}),
    mob: new THREE.MeshLambertMaterial({color: 0x00ff00})
  };

  const blockGeo = new THREE.BoxGeometry(1,1,1);

  // Armazenar blocos
  const blocks = new Map();

  function keyFromPos(x,y,z){
    return `${x},${y},${z}`;
  }

  function addBlock(x,y,z,type){
    const key = keyFromPos(x,y,z);
    if(blocks.has(key)) return;
    const mesh = new THREE.Mesh(blockGeo, materials[type]);
    mesh.position.set(x,y,z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.userData = { key, type };
    scene.add(mesh);
    blocks.set(key, mesh);
  }

  function removeBlock(x,y,z){
    const key = keyFromPos(x,y,z);
    const mesh = blocks.get(key);
    if(mesh){
      scene.remove(mesh);
      blocks.delete(key);
    }
  }

  // Criar chão 20x1x20 blocos terra
  const worldSize = 20;
  for(let x = -worldSize/2; x < worldSize/2; x++){
    for(let z = -worldSize/2; z < worldSize/2; z++){
      addBlock(x,0,z,'terra');
    }
  }

  // Posicionar câmera no meio do chão
  camera.position.set(0, playerHeight, 0);

  // Raycaster para interação
  const raycaster = new THREE.Raycaster();

  function getIntersectedBlock(){
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
    const intersect = raycaster.intersectObjects(Array.from(blocks.values()));
    if(intersect.length > 0){
      return intersect[0];
    }
    return null;
  }

  // Colocar / remover blocos com clique
  window.addEventListener('mousedown', e => {
    if(!controls.isLocked) return;
    e.preventDefault();
    const intersect = getIntersectedBlock();
    if(!intersect) return;
    if(e.button === 0){ // esquerdo - colocar bloco
      const pos = intersect.point.clone().add(intersect.face.normal.clone().multiplyScalar(0.5));
      const x = Math.floor(pos.x + 0.5);
      const y = Math.floor(pos.y + 0.5);
      const z = Math.floor(pos.z + 0.5);
      addBlock(x,y,z, selectedBlock);
    } else if(e.button === 2){ // direito - remover bloco
      const mesh = intersect.object;
      if(mesh.position.y > 0) removeBlock(mesh.position.x, mesh.position.y, mesh.position.z);
    }
  });

  window.addEventListener('contextmenu', e => e.preventDefault());

  // Checar colisão jogador com blocos (simplificado)
  function isSolidBlock(x,y,z){
    return blocks.has(keyFromPos(x,y,z));
  }

  // Função para checar colisão em uma posição futura
  function checkCollision(pos){
    // O jogador ocupa de pos.y até pos.y + playerHeight
    // Vamos testar pontos na base e meio
    const px = Math.floor(pos.x);
    const py = Math.floor(pos.y);
    const pz = Math.floor(pos.z);

    // Verificar blocos em volta (1 bloco de margem)
    for(let x = px-1; x <= px+1; x++){
      for(let y = py; y <= py + Math.ceil(playerHeight); y++){
        for(let z = pz-1; z <= pz+1; z++){
          if(isSolidBlock(x,y,z)){
            // Simplesmente bloquear se o jogador estiver muito perto (dentro de 0.5 bloco)
            const blockPos = new THREE.Vector3(x+0.5,y,z+0.5);
            if(pos.distanceTo(blockPos) < 0.7) return true;
          }
        }
      }
    }
    return false;
  }

  // Mob passivo (cubo verde que anda aleatório)
  const mob = new THREE.Mesh(blockGeo, materials.mob);
  mob.position.set(3,1,3);
  scene.add(mob);

  let mobDir = new THREE.Vector3(1,0,0);
  let mobMoveTimer = 0;

  // Loop de animação
  let prevTime = performance.now();

  function animate(){
    requestAnimationFrame(animate);

    const time = performance.now();
    const delta = (time - prevTime) / 1000;
    prevTime = time;

    if(controls.isLocked){
      // Movimentação jogador
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      velocity.y -= gravity * delta;

      direction.z = (move.forward ? -1 : 0) + (move.backward ? 1 : 0);
      direction.x = (move.left ? -1 : 0) + (move.right ? 1 : 0);
      direction.normalize();

      if(move.forward || move.backward) velocity.z -= direction.z * 50.0 * delta;
      if(move.left || move.right) velocity.x -= direction.x * 50.0 * delta;

      // Tentativa de mover com colisão simples
      let nextPos = camera.position.clone();
      nextPos.x += velocity.x * delta;
      if(!checkCollision(nextPos)) camera.position.x = nextPos.x;
      nextPos.z += velocity.z * delta;
      if(!checkCollision(nextPos)) camera.position.z = nextPos.z;

      velocity.y = Math.max(velocity.y, -100);

      nextPos.y = camera.position.y + velocity.y * delta;

      // Colisão com chão
      if(nextPos.y < playerHeight){
        velocity.y = 0;
        nextPos.y = playerHeight;
        canJump = true;
      } else if(checkCollision(nextPos)){
        velocity.y = 0;
      }

      camera.position.y = nextPos.y;

      controls.getObject().position.copy(camera.position);

      // Atualizar mob simples
      mobMoveTimer -= delta;
      if(mobMoveTimer <= 0){
        mobMoveTimer = 3 + Math.random()*2;
        // Escolher direção aleatória no plano XZ
        const angle = Math.random() * Math.PI*2;
        mobDir.set(Math.cos(angle), 0, Math.sin(angle));
      }
      // Mover mob
      const mobNextPos = mob.position.clone().addScaledVector(mobDir, delta*1.5);
      if(!isSolidBlock(Math.floor(mobNextPos.x), Math.floor(mobNextPos.y), Math.floor(mobNextPos.z))){
        mob.position.copy(mobNextPos);
      } else {
        mobDir.negate();
      }
    }

    renderer.render(scene, camera);
  }

  animate();

  // Ajustar canvas no resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>
</body>
</html>
